mod ai_brain;
mod layout_engine;
mod particle_system;
mod renderer;

use layout_engine::LayoutEngine;
use particle_system::ParticleSystem;
use renderer::Renderer;
use std::sync::Arc;
use std::time::Instant;
use winit::{
    application::ApplicationHandler,
    event::*,
    event_loop::{ActiveEventLoop, ControlFlow, EventLoop},
    keyboard::{KeyCode, PhysicalKey},
    window::{Window, WindowId},
};

const PARTICLE_COUNT: usize = 500;

struct App {
    renderer: Option<Renderer>,
    particle_system: Option<ParticleSystem>,
    layout_engine: Option<LayoutEngine>,
    start_time: Instant,
    window: Option<Arc<Window>>,
}

impl App {
    fn new() -> Self {
        Self {
            renderer: None,
            particle_system: None,
            layout_engine: None,
            start_time: Instant::now(),
            window: None,
        }
    }

    // Removed preset methods - now purely AI-driven via command-line

    fn update(&mut self) {
        if let Some(particle_system) = &mut self.particle_system {
            particle_system.update();
        }
    }

    fn render(&mut self) {
        if let (Some(renderer), Some(particle_system)) = (&mut self.renderer, &self.particle_system) {
            let elapsed = self.start_time.elapsed().as_secs_f32();

            match renderer.render(particle_system, elapsed) {
                Ok(_) => {}
                Err(wgpu::SurfaceError::Lost) => {
                    let size = renderer.size();
                    renderer.resize(size);
                }
                Err(wgpu::SurfaceError::OutOfMemory) => panic!("Out of memory!"),
                Err(e) => eprintln!("Render error: {:?}", e),
            }
        }
    }
}

impl ApplicationHandler for App {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        if self.window.is_none() {
            let window_attributes = Window::default_attributes()
                .with_title("Project Tofu - Rust + wgpu")
                .with_inner_size(winit::dpi::LogicalSize::new(800, 600));

            let window = Arc::new(event_loop.create_window(window_attributes).unwrap());
            self.window = Some(window.clone());

            // Initialize renderer asynchronously
            let size = window.inner_size();
            let renderer = pollster::block_on(Renderer::new(window.clone(), PARTICLE_COUNT));
            self.renderer = Some(renderer);

            // Initialize particle system
            self.particle_system = Some(ParticleSystem::new(
                PARTICLE_COUNT,
                size.width as f32,
                size.height as f32,
            ));

            // Initialize layout engine
            self.layout_engine = Some(LayoutEngine::new(size.width as f32, size.height as f32));

            println!("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
            println!("‚ïë      üßä Project Tofu - Living UI üßä            ‚ïë");
            println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
            println!("\n‚ú® Pure AI-Driven Interface");
            println!("   No presets. No hardcoded shapes.");
            println!("   Everything generated by AI in real-time.");
            println!("\nüöÄ Usage:");
            println!("   cargo run --release -- \"your natural language prompt\"");
            println!("\nüí° Examples:");
            println!("   cargo run --release -- \"show me a DNA helix\"");
            println!("   cargo run --release -- \"create a spiral galaxy\"");
            println!("   cargo run --release -- \"visualize quantum particles\"");
            println!("\n‚å®Ô∏è  Controls:");
            println!("   ESC - Quit");
            println!("\nüìñ Waiting for AI-generated layout...\n");
        }
    }

    fn window_event(
        &mut self,
        event_loop: &ActiveEventLoop,
        _window_id: WindowId,
        event: WindowEvent,
    ) {
        match event {
            WindowEvent::CloseRequested
            | WindowEvent::KeyboardInput {
                event:
                    KeyEvent {
                        physical_key: PhysicalKey::Code(KeyCode::Escape),
                        ..
                    },
                ..
            } => {
                event_loop.exit();
            }

            WindowEvent::Resized(physical_size) => {
                if let Some(renderer) = &mut self.renderer {
                    renderer.resize(physical_size);
                    self.layout_engine = Some(LayoutEngine::new(
                        physical_size.width as f32,
                        physical_size.height as f32,
                    ));
                }
            }

            // All keyboard controls removed - purely AI-driven interface
            // Only ESC to quit (handled above in CloseRequested match)

            WindowEvent::RedrawRequested => {
                self.update();
                self.render();
                if let Some(window) = &self.window {
                    window.request_redraw();
                }
            }

            _ => {}
        }
    }

    fn about_to_wait(&mut self, _event_loop: &ActiveEventLoop) {
        if let Some(window) = &self.window {
            window.request_redraw();
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
fn main() {
    // Load environment variables from .env file
    dotenv::dotenv().ok();

    // Set up logging
    env_logger::init();

    // Check for command-line arguments (AI mode)
    let args: Vec<String> = std::env::args().collect();

    if args.len() > 1 {
        // AI Mode: User provided natural language prompt
        let prompt = args[1..].join(" ");
        run_ai_mode(&prompt);
    } else {
        // GUI Mode: Interactive windowed app
        run_gui_mode();
    }
}

/// AI Mode: Translate natural language ‚Üí JSON ‚Üí Render once
fn run_ai_mode(prompt: &str) {
    use tokio::runtime::Runtime;

    println!("\nüßä Project Tofu - AI Mode");
    println!("Natural Language: \"{}\"", prompt);
    println!("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");

    // Create async runtime
    let rt = Runtime::new().unwrap();

    // Translate natural language to JSON
    let json_result = rt.block_on(async {
        match ai_brain::AIBrain::new() {
            Ok(brain) => brain.translate_to_json(prompt).await,
            Err(e) => {
                eprintln!("\n‚ùå Failed to initialize AI Brain:");
                eprintln!("   {}", e);
                eprintln!("\nüí° To fix this:");
                eprintln!("   1. Get a free Gemini API key: https://makersuite.google.com/app/apikey");
                eprintln!("   2. Copy .env.example to .env");
                eprintln!("   3. Add your API key to .env");
                eprintln!("\n   See GEMINI_SETUP.md for detailed instructions.");
                std::process::exit(1);
            }
        }
    });

    let json = match json_result {
        Ok(j) => j,
        Err(e) => {
            eprintln!("\n‚ùå AI translation failed: {}", e);
            std::process::exit(1);
        }
    };

    println!("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    println!("‚ú® Rendering layout...\n");

    // Now run the GUI with this JSON
    run_gui_mode_with_json(&json);
}

/// GUI Mode: Interactive windowed app
fn run_gui_mode() {
    let event_loop = EventLoop::new().unwrap();
    event_loop.set_control_flow(ControlFlow::Poll);
    let mut app = App::new();
    event_loop.run_app(&mut app).unwrap();
}

/// GUI Mode with initial JSON layout
fn run_gui_mode_with_json(json: &str) {
    let event_loop = EventLoop::new().unwrap();
    event_loop.set_control_flow(ControlFlow::Poll);
    let mut app = AppWithInitialJSON::new(json.to_string());
    event_loop.run_app(&mut app).unwrap();
}

/// App variant that starts with a JSON layout (for AI mode)
struct AppWithInitialJSON {
    inner: App,
    initial_json: Option<String>,
}

impl AppWithInitialJSON {
    fn new(json: String) -> Self {
        Self {
            inner: App::new(),
            initial_json: Some(json),
        }
    }
}

impl ApplicationHandler for AppWithInitialJSON {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        // Initialize the inner app
        self.inner.resumed(event_loop);

        // Load the initial JSON layout
        if let Some(json) = self.initial_json.take() {
            if let (Some(layout_engine), Some(particle_system)) =
                (&self.inner.layout_engine, &mut self.inner.particle_system)
            {
                let targets = layout_engine.generate_from_json_str(&json, PARTICLE_COUNT);
                particle_system.set_targets(&targets);
            }
        }
    }

    fn window_event(
        &mut self,
        event_loop: &ActiveEventLoop,
        window_id: WindowId,
        event: WindowEvent,
    ) {
        self.inner.window_event(event_loop, window_id, event);
    }

    fn about_to_wait(&mut self, event_loop: &ActiveEventLoop) {
        self.inner.about_to_wait(event_loop);
    }
}

// WebAssembly entry point
#[cfg(target_arch = "wasm32")]
fn main() {
    std::panic::set_hook(Box::new(console_error_panic_hook::hook));
    console_log::init_with_level(log::Level::Warn).expect("Failed to initialize logger");

    wasm_bindgen_futures::spawn_local(run());
}

#[cfg(target_arch = "wasm32")]
async fn run() {
    let event_loop = EventLoop::new().unwrap();
    let mut app = App::new();

    event_loop.run_app(&mut app).unwrap();
}
