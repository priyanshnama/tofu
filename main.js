/**
 * main.js — tofu  (1D, 5000 atoms, WebGPU)
 *
 * Each atom has one number: its x-position. That's the entire universe.
 * Rendered as a vertical tick mark so density shows up as a bright/solid band.
 *
 * Shape cycling
 * ─────────────
 * Loads public/shapes.bin + public/shapes.json (generated by ot_assignment.py).
 * Cycles through all shapes automatically:
 *   1. Compute 1D OT on the JS side (sort both arrays, pair by rank — O(N log N))
 *   2. Upload source/target to GPU
 *   3. Interpolate:  pos(t) = (1−t)·source  +  t·target   over MORPH_DURATION seconds
 *   4. Hold HOLD_DURATION seconds at target
 *   5. Advance to next shape, repeat forever
 *
 * The OT sort ensures non-crossing geodesics: the k-th leftmost atom always
 * travels to the k-th leftmost target, so trajectories never intersect.
 */

// ═══════════════════════════════════════════════════════════════════════════
// Constants
// ═══════════════════════════════════════════════════════════════════════════

const N          = 5_000;
const WORKGROUP  = 64;
const DISPATCH   = Math.ceil(N / WORKGROUP);   // 79

const PARTICLE_BYTES = N * 2 * 4;   // {pos_x, vel_x} × N = 40 KB
const OT_BYTES       = N * 4;       // one f32 per atom  = 20 KB

const MAX_VEL        = 0.55;
const MORPH_DURATION = 1.5;   // seconds: source → target travel
const HOLD_DURATION  = 2.5;   // seconds: pause at target before next shape


// ═══════════════════════════════════════════════════════════════════════════
// WGSL — Compute shader
// ═══════════════════════════════════════════════════════════════════════════

const COMPUTE_WGSL = /* wgsl */`

struct Particle { pos_x : f32, vel_x : f32 }

struct SimParams {
    dt          : f32,
    time        : f32,
    has_targets : f32,
    morph_t     : f32,
}

@group(0) @binding(0) var<storage, read>       src_buf    : array<Particle>;
@group(0) @binding(1) var<storage, read_write> dst_buf    : array<Particle>;
@group(0) @binding(2) var<uniform>             params     : SimParams;
@group(0) @binding(3) var<storage, read>       target_buf : array<f32>;
@group(0) @binding(4) var<storage, read>       source_buf : array<f32>;

@compute @workgroup_size(${WORKGROUP})
fn cs_main(@builtin(global_invocation_id) gid : vec3<u32>) {
    let idx = gid.x;
    if idx >= ${N}u { return; }

    var p = src_buf[idx];

    if params.has_targets > 0.5 {
        let t  = clamp(params.morph_t, 0.0, 1.0);
        let te = t * t * (3.0 - 2.0 * t);   // smoothstep — fast start, clean finish
        let sx = source_buf[idx];
        let tx = target_buf[idx];
        p.pos_x = (1.0 - te) * sx + te * tx;
        p.vel_x = (tx - sx) * (1.0 - te);   // dims to zero on arrival
        dst_buf[idx] = p;
        return;
    }

    // Wander: sinusoidal noise + soft walls
    let fi = f32(idx);
    let t  = params.time;
    let force = (sin(t * 1.30 + fi * 0.00731) + sin(t * 2.10 + fi * 0.00517) * 0.4) * 0.10;
    var wall  = 0.0;
    if p.pos_x < -0.93 { wall =  6.0 * (-0.93 - p.pos_x); }
    if p.pos_x >  0.93 { wall = -6.0 * ( p.pos_x - 0.93); }
    p.vel_x = (p.vel_x + (force + wall) * params.dt) * 0.994;
    if abs(p.vel_x) > ${MAX_VEL} { p.vel_x = sign(p.vel_x) * ${MAX_VEL}; }
    p.pos_x = clamp(p.pos_x + p.vel_x * params.dt, -1.0, 1.0);
    dst_buf[idx] = p;
}
`;


// ═══════════════════════════════════════════════════════════════════════════
// WGSL — Render shaders
// ═══════════════════════════════════════════════════════════════════════════

const RENDER_WGSL = /* wgsl */`

struct Particle { pos_x : f32, vel_x : f32 }

@group(0) @binding(0) var<storage, read> particles : array<Particle>;

struct VSOut {
    @builtin(position) pos   : vec4<f32>,
    @location(0)       speed : f32,
}

@vertex
fn vs_main(@builtin(vertex_index) vi : u32) -> VSOut {
    let atom = vi / 2u;
    let p    = particles[atom];
    let y    = select(-0.06, 0.06, (vi % 2u) == 0u);   // top / bottom of tick

    var out : VSOut;
    out.pos   = vec4<f32>(p.pos_x, y, 0.0, 1.0);
    out.speed = abs(p.vel_x);
    return out;
}

@fragment
fn fs_main(in : VSOut) -> @location(0) vec4<f32> {
    let t = clamp(in.speed / ${MAX_VEL}, 0.0, 1.0);
    return vec4<f32>(0.0, 0.45 + t * 0.55, t * 0.10, 1.0);
}
`;


// ═══════════════════════════════════════════════════════════════════════════
// 1D Optimal Transport — pure JS, O(N log N)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Monotone rearrangement: sort both arrays, pair by rank.
 * Returns a new Float32Array where result[i] is the OT-assigned target for source[i].
 * Guarantees non-crossing paths.
 */
function ot1D(source, target) {
    const n  = source.length;
    const si = Array.from({ length: n }, (_, i) => i).sort((a, b) => source[a] - source[b]);
    const ti = Array.from({ length: n }, (_, i) => i).sort((a, b) => target[a] - target[b]);
    const out = new Float32Array(n);
    for (let k = 0; k < n; k++) out[si[k]] = target[ti[k]];
    return out;
}


// ═══════════════════════════════════════════════════════════════════════════
// Helpers
// ═══════════════════════════════════════════════════════════════════════════

function showError(msg) {
    document.getElementById('error-msg').textContent = msg;
    document.getElementById('error').classList.add('visible');
}

function checkShader(label, info) {
    for (const m of info.messages)
        console.warn(`[${label}] ${m.type} L${m.lineNum}: ${m.message}`);
    return info.messages.filter(m => m.type === 'error');
}


// ═══════════════════════════════════════════════════════════════════════════
// Main
// ═══════════════════════════════════════════════════════════════════════════

async function main() {

    // ── WebGPU ────────────────────────────────────────────────────────────────

    if (!navigator.gpu) { showError('WebGPU not supported.'); return; }
    const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
    if (!adapter) { showError('No WebGPU adapter.'); return; }
    const device = await adapter.requestDevice({ label: '1D Atoms' });
    device.lost.then(i => showError(`GPU lost: ${i.message}`));

    const canvas  = document.getElementById('canvas');
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    const ctx    = canvas.getContext('webgpu');
    const format = navigator.gpu.getPreferredCanvasFormat();
    ctx.configure({ device, format, alphaMode: 'opaque' });

    // ── Initial seed (uniform scatter) ────────────────────────────────────────

    const seedData = new Float32Array(N * 2);
    for (let i = 0; i < N; i++) {
        seedData[i * 2    ] = (Math.random() * 2 - 1) * 0.85;
        seedData[i * 2 + 1] = (Math.random() - 0.5) * 0.08;
    }

    // ── GPU buffers ───────────────────────────────────────────────────────────

    const particleBufs = [0, 1].map(() => {
        const b = device.createBuffer({ size: PARTICLE_BYTES, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        device.queue.writeBuffer(b, 0, seedData);
        return b;
    });

    const cpuSource = new Float32Array(N);
    const cpuTarget = new Float32Array(N);
    for (let i = 0; i < N; i++) cpuSource[i] = cpuTarget[i] = seedData[i * 2];

    const sourceBuf = device.createBuffer({ label: 'Source', size: OT_BYTES, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const targetBuf = device.createBuffer({ label: 'Target', size: OT_BYTES, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    device.queue.writeBuffer(sourceBuf, 0, cpuSource);
    device.queue.writeBuffer(targetBuf, 0, cpuTarget);

    const simBuf  = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    const simData = new Float32Array(4);   // [dt, time, has_targets, morph_t]

    // ── Shaders & pipelines ───────────────────────────────────────────────────

    const computeMod = device.createShaderModule({ label: 'Compute', code: COMPUTE_WGSL });
    const renderMod  = device.createShaderModule({ label: 'Render',  code: RENDER_WGSL  });
    const [ci, ri]   = await Promise.all([computeMod.getCompilationInfo(), renderMod.getCompilationInfo()]);
    if ([...checkShader('Compute', ci), ...checkShader('Render', ri)].length)
        { showError('Shader error — see console'); return; }

    const computePipeline = await device.createComputePipelineAsync({
        label: 'Compute', layout: 'auto',
        compute: { module: computeMod, entryPoint: 'cs_main' },
    });
    const renderPipeline = await device.createRenderPipelineAsync({
        label: 'Render', layout: 'auto',
        vertex:   { module: renderMod, entryPoint: 'vs_main' },
        fragment: { module: renderMod, entryPoint: 'fs_main', targets: [{ format }] },
        primitive: { topology: 'line-list' },
    });

    const computeBGs = [0, 1].map(s => device.createBindGroup({
        layout: computePipeline.getBindGroupLayout(0),
        entries: [
            { binding: 0, resource: { buffer: particleBufs[s]     } },
            { binding: 1, resource: { buffer: particleBufs[1 - s] } },
            { binding: 2, resource: { buffer: simBuf               } },
            { binding: 3, resource: { buffer: targetBuf            } },
            { binding: 4, resource: { buffer: sourceBuf            } },
        ],
    }));
    const renderBGs = [0, 1].map(s => device.createBindGroup({
        layout: renderPipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer: particleBufs[1 - s] } }],
    }));

    // ── Morph state (declared before goToShape so it is in scope) ────────────

    const morph = { t: 0.0, hold: 0.0 };

    // ── Load all shapes ───────────────────────────────────────────────────────

    const statusEl = document.getElementById('status');
    let shapes     = [];    // Array of Float32Array(N), one per shape
    let names      = [];    // Display names
    let shapeIdx   = -1;    // current shape index (-1 = not started yet)

    /** Transition to a specific shape index, computing OT from current positions. */
    function goToShape(idx) {
        shapeIdx = idx;
        const targetShape = shapes[idx];

        // 1D OT: sort current positions vs target, pair by rank
        const paired = ot1D(cpuSource, targetShape);
        cpuTarget.set(paired);

        device.queue.writeBuffer(sourceBuf, 0, cpuSource);
        device.queue.writeBuffer(targetBuf, 0, cpuTarget);

        morph.t    = 0.0;
        morph.hold = 0.0;
        simData[2] = 1.0;   // has_targets
        simData[3] = 0.0;   // morph_t

        statusEl.textContent = names[idx];
    }

    try {
        const [jsonRes, binRes] = await Promise.all([
            fetch('/shapes.json'),
            fetch('/shapes.bin'),
        ]);

        if (!jsonRes.ok || !binRes.ok) throw new Error('shapes files not found');

        names = await jsonRes.json();
        const raw = new Float32Array(await binRes.arrayBuffer());

        for (let i = 0; i < names.length; i++)
            shapes.push(raw.slice(i * N, (i + 1) * N));

        console.log(`[shapes] loaded ${shapes.length} shapes:`, names);

        // Start at first shape
        goToShape(0);

    } catch (e) {
        console.warn('[shapes] could not load —', e.message, '— running in wander mode');
        statusEl.textContent = 'wander';
    }

    // ── Frame loop ────────────────────────────────────────────────────────────

    let frame    = 0;
    let lastMs   = performance.now();
    let totalSec = 0;
    let fpsCount = 0, fpsStart = performance.now();
    const fpsEl  = document.getElementById('fps');

    function tick() {
        const now = performance.now();
        const dt  = Math.min((now - lastMs) / 1000, 0.033);
        lastMs    = now;
        totalSec += dt;

        if (++fpsCount, now - fpsStart >= 1000) {
            fpsEl.textContent = `${Math.round(fpsCount * 1000 / (now - fpsStart))} fps`;
            fpsCount = 0; fpsStart = now;
        }

        // ── Shape cycling ─────────────────────────────────────────────────────
        if (simData[2] > 0.5 && shapes.length > 0) {
            if (morph.t < 1.0) {
                morph.t = Math.min(morph.t + dt / MORPH_DURATION, 1.0);
            } else {
                morph.hold += dt;
                if (morph.hold >= HOLD_DURATION) {
                    // Atoms are now at cpuTarget — that becomes the new source
                    cpuSource.set(cpuTarget);
                    goToShape((shapeIdx + 1) % shapes.length);
                }
            }
            simData[3] = morph.t;
        }

        simData[0] = dt;
        simData[1] = totalSec;
        device.queue.writeBuffer(simBuf, 0, simData);

        const slot = frame & 1;
        const enc  = device.createCommandEncoder();

        const cp = enc.beginComputePass();
        cp.setPipeline(computePipeline);
        cp.setBindGroup(0, computeBGs[slot]);
        cp.dispatchWorkgroups(DISPATCH);
        cp.end();

        const rp = enc.beginRenderPass({
            colorAttachments: [{
                view: ctx.getCurrentTexture().createView(),
                clearValue: { r: 0, g: 0, b: 0, a: 1 },
                loadOp: 'clear', storeOp: 'store',
            }],
        });
        rp.setPipeline(renderPipeline);
        rp.setBindGroup(0, renderBGs[slot]);
        rp.draw(N * 2);   // 2 vertices per atom (line-list)
        rp.end();

        device.queue.submit([enc.finish()]);
        frame++;
        requestAnimationFrame(tick);
    }

    requestAnimationFrame(tick);
}

main().catch(e => { console.error(e); showError(String(e)); });
